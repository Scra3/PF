qsort [] = []
qsort (x:xs) = 
	qsort smaller ++ [x] ++ qsort larger
	where
		smaller = [a | a <- xs, a < x]
		larger  = [b | b <- xs, x < b]
		
		
safetail1:: [a] -> [a]	
safetail2:: [a] -> [a]	
safetail3:: [a] -> [a]	

-- Conditionnelle
safetail1 xs  =
	if length xs <= 1 then [] else
	tail xs
	
--Condition de garde
safetail2 xs 
	| length xs <= 1 = []
	| otherwise = tail xs
	
-- Filtrage par motif 
safetail3  [] = []
safetail3  (_ :[]) = []
safetail3  (_ : others) = others
	
	
-- EXO 4
carre:: Num a => a -> a
carre x = x^2
--Num hérite de fractionnal qui hérite de floating (:info)
moyenne:: Floating a => [a] -> a
moyenne ns = sum ns / fromIntegral (length ns)

norme:: Floating a => [a] -> a
norme ns = sqrt (moyenne (map carre ns))
main = print ( norme [1..5])

-- EXO 5

repeat' :: Int -> (value -> value) -> value -> value
repeat' 0 _ x =  x
repeat' n f x = repeat' (n-1) f (f x) 


add n p = repeat' n (+1) p

mult n p = repeat' n (add p) 0

power n exponent = repeat' exponent (mult n) 1 


distMoy = \xs ys -> (\zs -> sum zs / fromIntegral (length zs))
		(map (\(x,y) -> abs ( x - y )) ( zip xs ys ))


	
-- EXO 6

produitScalaire :: Num a => ([a],[a])-> a

produitScalaire (xs,ys) =  sum [xi*yi|(xi,yi) <- (zip xs ys)]

-- EXO 7
factors :: Int-> [Int]
factors n = [x | x <- [1..n-1], n `mod` x == 0]

nombreParfait :: Int -> (Int,Int,[Int])
nombreParfait n = (n,sum (factors n), (factors n))

-- Exo 8  x2 + y2 = z2.
pyth :: Int -> [(Int,Int,Int)]
pyth n = [ ( a, b, c ) | a <- [1..n],          -- Pythagorean Triples
                         b <- [1..n], 
                         c <- [1..n], 
                         a + b + c <= n, 
                         a^2 + b^2 == c^2 ]
